# Monad concept

This is just a fun little implementation of monads as a [`concept`](https://en.cppreference.com/w/cpp/language/constraints), based on an [answer on StackOverflow](https://stackoverflow.com/a/39730419).

> As mentioned in that answer, we cannot assert the axioms of monadicity at compile time, but we can at least require the appropriate scaffolding is provided.

Given a templated type `F<X>`, we can exhibit `F` as a monad using the concepts in `monad.hpp`.


### Functoriality

We exhibit `F<X>` as *functorial* in `X` by specialising `functional::functor` as follows:

```cpp
/**
 * Specification for how maps f : X -> Y become maps F<f> : F<X> -> F<Y>
 */
template<typename X, typename Y>
struct functorial::functor<F, X, Y>
{
    static std::function<F<Y>(F<X> &&)> fmap(std::function<Y(X &&)>);
};
```

In other words, `fmap` provides the action of the functor $`F : \mathbf{Type} \to \mathbf{Type}`$ on Hom-sets.
By specifying `fmap`, the templated type `F` will satisfy the constraint `functional::functorial<F>`.

### Monadicity

To exhibit `F<X>` as *monadic*, we also specialise `functional::monad` as follows:

```cpp
/**
 * Specification of monad unit and multiplication.
 * Note: F is required to satisfy functional::functoriality prior to
 *       specialising functional::monad.
 */
template<typename X>
struct functional::monad<F, X>
{
    /* unit */
    static F<X> ret(X &&);
    /* multiplication */
    static F<X> join(F<F<X>> &&);
};
```

The templated function `ret` provides the components of the monad unit $`\eta_X : X \to FX`$ for $`X\in\mathbf{Type}`$, and the templated function `join` provides the components of the monad multiplication $`\mu_X : F(FX) \to FX`$.

By specifying `ret` and `join`, the functor `F` will satisfy the constraint `functional::monadic<F>`.

### Additional functionality

Although unit and multiplication are the most natural way of defining monads in mathematics, it seems that functional programmers are more interested in `bind`, which is the natural transformation
```math
\mathrm{bind}_{X,Y} : [X, FY] \xrightarrow{F_{X,Y}} {[FX, F(FY)]} \xrightarrow{\mu_{Y,*}} {[FX, FY]}
```
as it provides a means to embed imperative programs into a functional language (perhaps after uncurrying).

Once a templated type `F` satisfies `functional::monadic<F>`, you can use the templated `bind` function with `F`:

```cpp
template<typename X, typename Y>
std::function<F<Y>(F<X> &&)> bind(std::function<F<Y>(X &&)>);
```

Just for fun, `monad.hpp` also provides a means of using `bind` as an infix operator, by wrapping it with `/`s.
In other words, `/bind/` behaves similar to `>>=` in Haskell (it is even left-associative!).

> *Note.* Unfortunately, even if a "real" infix operator (such as `operator>>=`, though this is right-associative) were used, C++ has a difficult time deducing the types in a `bind`, so `/bind/` needs to be explicitly templated.

There is also an `as_pure` function, which converts a pure function `f : X -> Y` to a Kleisli map `X -> F<Y>` (by post-composing with `ret`).


## Example

The `cpp` files provide some examples of monads.

| File | Monad |
|:----:|:----- |
| `identity.cpp` | The trivial "do nothing" monad induced by $`\mathrm{Id} : \mathbf{Set} \to \mathbf{Set}`$ |
| `maybe.cpp` | The `Maybe` monad, induced by the forgetful functor $`\mathbf{Set}_*\to\mathbf{Set}`$ from pointed sets. |
| `vector.cpp` | The `List` monad, induced by the forgetful functor $`\mathbf{Mon}\to\mathbf{Set}`$ from monoids. |
| `state.cpp` | A `State` monad, induced by the currying adjunction $`(-)\times S : \mathbf{Set}\rightleftarrows\mathbf{Set} : (-)^S`$ for a fixed set $`S`$ |

We'll also walk through another monad here, to document how to use `monad.hpp`: the "writer" monad (`writer.cpp`).

To a mathematician, the "writer" monad is better known as the "action" monad for a fixed monoid $`M`$, induced by the forgetful functor $`M\mathbf{Set}\to\mathbf{Set}`$ from left $`M`$-sets.

Perhaps the writer monad is specific to the setting where the monoid $`M`$ is the free monoid generated by printable characters, in which case the computational effect encoded by the monad corresponds to appending to a character output stream.
This is what we will implement here; that is, we take $`M`$ to be the monoid given by `std::string` and concatenation.

### Functoriality

Being induced by the forgetful functor $`M\mathbf{Set}\to\mathbf{Set}`$ means that the underlying functor of our monad $`F`$ is given by
```math
F(X) = M\times X
```

We implement this as a templated type in C++ as follows:
```cpp
#include "monad.hpp"
#include <string>
using namespace std; // for brevity

template<typename X>
using Writer = pair<string, X>;
```

The functoriality in this case is clear: for a map $`f : X \to Y`$, the induced map $`Ff : M\times X\to M\times Y`$ simply acts by $`f`$ on the second component.
We encode this by specialising `functional::functor`:
```cpp
// Writer<X> is functorial in X
template<typename X, typename Y>
struct functional::functor<Writer, X, Y>
{
    static function<Writer<Y>(Writer<X> const &&)>
    fmap(function<Y(X const &&)> morphism)
    {
        return [morphism](Writer<X> const &&writer)->Writer<Y>
        {
            auto &&[ content, x ] = writer;
            // apply the morphism only to the second component
            return { content, morphism(forward<X const>(x)) };
        };
    }
};
```

### Monadicity

The action monad really reflects the cheeky statement that a monad is a monoid in an endofunctor category: the unit and multiplication of $`F = M\times(-)`$ are induced precisely by the unit and multiplication of $`M`$.

In our case, multiplication in `std::string` is given by concatenation `+`, and the corresponding unit is the empty string `""`.
We encode the corresponding unit and multiplication of our monad $`F`$ by specialising `functional::monad`:
```cpp
// Writer<X> is monadic in X
template<typename X>
struct functional::monad<Writer, X>
{
    // ret is the monad unit, given by ""
    static Writer<X> ret(X const &&val)
    {
        return { "", val };
    }

    // join is the monad multiplication, given by concatenation
    static Writer<X> join(Writer<Writer<X>> const &&ww)
    {
        // ww = [ lhs, [ rhs, x ] ]
        auto &&[ lhs, w ] = ww;
        auto &&[ rhs, x ] = w;
        return { lhs + rhs, x };
    }
};
```

### In action

That's it, we now have a monad structure on `Writer`, and we can use it to collect output while performing computations.

For example, we an implement the following simple (purposeless) program:

```cpp
    cout << "Test.\n";
    int x = 15;
    x /= 3;
    cout << x << '\n';
    x = 4;
    cout << "Forget about " << x << ".\n";
    string s("Hello!");
    cout << s << endl;
    x = s.size();
```

Indeed, the writes to `cout` can be bundled up with our `Writer` monad, and the sequence of instructions can be expressed as a composite of calls to `bind`.

```cpp
int main()
{
    using functional::bind, functional::as_pure;

    auto &&[ output, _ ] = (
            // cout << "Test.\n";
            // int x = 15;
        Writer<int> { "Test.\n", 15 }
            // x /= 3;
        /bind<Writer, int, int>/
            as_pure<Writer, int, int>([](int x) -> int
            {
                return x / 3;
            })
            // cout << x << '\n';
            // x = 4;
        /bind<Writer, int, int>/
            [](int x) -> Writer<int>
            {
                return { to_string(x) + "\n", /* x = */ 4 };
            }
            // cout << "Forget about " << x << ".\n";
            // string s("Hello!");
        /bind<Writer, int, string>/
            [](int x) -> Writer<string>
            {
                return { "Forget about " + to_string(x) + ".\n", /* s = */ "Hello!" };
            }
            // cout << s << endl;
            // x = s.size();
        /bind<Writer, string, int>/
            [](string s) -> Writer<int>
            {
                return { s, /* x = */ s.size() };
            }
        );

    cout << message << endl;

    return 0;
}
```
